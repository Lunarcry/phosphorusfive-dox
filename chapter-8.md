# Introduction - The pan galactical gargle blaster

**Warning**; Everything you thought you knew, is wrong!

My *"theory of mind"* is based upon the assumption that the same way Newton's laws applies to physical things and energies, it also to some extent applies to cognitive energies. This implies that whenever you apply cognitive energies to creating software, the thing you are trying to create, applies the same amount of cognitive energy back unto your brain. If my theory is correct, this implies, that as you create software, the software you create, modifies your brain.

Today, there are probably few objections to my assumption of that software developers are gravitating towards their *"left hemisphere"*, in regards to all cognitive types of energies. This starves the right hemisphere, which is where our creativity is seated. If you don't believe me, then please go an *"create an app"*. Nope, I will not tell you *which* app to create, just create *"whatever"*.

Phosphorus Five, forces you to visualize that which is *"not there"*. Meaning, the intangible stuff, that's inbetween your code. This forces you to use your right hemisphere, to a much larger extent, than traditional programming. The **[apply]** active event from our previous chapter, is one example of this.

This has the effect of *"balancing your brain"*, such that the art of programming, doesn't necessarily overfeed your left hemisphere, while starving your right - Instead, it nurtures *both* hemispheres equally much. This is the reason why I previously said that *"if you should learn only two programming languages, Hyperlambda should probably be one of these"*.

All other programming languages in today's world, are extremely logical beasts. Hyperlambda is a much more *"smooth"* programming language. Among other things, as we've clearly seen so far, it *"morphes"* in accordance to its environment, to a much larger extent, than what for instance a language such as C++ or C# does.

This trait of Hyperlambda, makes it a perfect *"orchestration programming language"*, allowing you to orchestrate your logical parts together, in a *"softer and more agile"* environment. In such a way, it solves something that has arguably never been solved previously in regards to the art of programming. The thing it solves, also happens to be a very useful thing!

## Should you use Hyperlambda for everything?

Short answer; **NO**! There are things that C# or C++ does much better than Hyperlambda. And Hyperlambda, might never be able to solve all things, as nicely as other programming languages solves these concepts. However, Hyperlambda was built to be an *"orchestration programming language"*. This allows you to take all of your beautiful algorithms, classes, and concrete pre-existing solutions, and *"melt them together"*, making them *"collaborate"* with each other. However, for this task, Hyperlambda and P5, is vastely superior, to everything else I have seen of similar frameworks out there.

The above explanation is the reason why I have waited with the introduction of this book, until chapter 8. Simply because this idea is difficult to believe in, before you've had some *"hands on experience"* with Hyperlambda.

At this point however, I think it is time to *"come clean with you"*, and tell you the truth! Hyperlambda is vastely different. It has no existing completition out there, that comes even close to its way of thinking - And this is its primary value! It allows you to do things differently, and almost equally important; It allows you to *think differently*!

If none of the above mentioned concepts have any value for you, you might as well stop reading, and go back to your strongly typed programming languages, with multiple inheritance, and generic template classes, creating partial specializations, through so many layers of *"pure logic"*, which forces you to see the world from an absurdely logical point of view. However, as for me, I am [done with that world](http://smartwin.sourceforge.net/)!

## Am I sorry ...?

Sorry for messing with your brain!

Or to be more honest with you; Sorry for being sorry for messing with your brain!

The last joke, is not funny in fact, unless you've done quite a lot of Hyperlambda development. However, if you know Hyperlambda's ins and out, you are probably laughing by now ... ;)

When you have read this entire bok, and create some rich app in Hyperlambda, you might even laugh of the following; *"Hyperlambda forgives you from you wanting me to apologize to you, for messing with your brain*". But that requires a *"Shaolin Ninja Kung-Fu Master degree"* in Hyperlambda to find funny ... :D

However, facts are, after a couple of months of Hyperlambda development, everything tends to become funny ... ;)
